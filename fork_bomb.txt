
参考链接:https://github.com/wzb56/13_questions_of_shell

一个能让系统shell崩溃的shell 片段：
:() { :|:& }; :      # <--- 这个别乱跑！好奇会死人的！
echo '十人|日一|十十o' | sed 's/.../&\n/g'   # <--- 跟你讲就不听，再跑这个就好了...
原来是一个bash的fork炸弹：ref：http://en.wikipedia.org/wiki/Fork_bomb

:() {

    :|:&
}
:
代码分析：

(即除最后一行外)

定义了一个 shell 函数，函数名是:，

而这个函数体执行一个后台命令:|:

即冒号命令(或函数，下文会解释)的输出 通过管道再传给冒号命令做输入

最后一行执行“:”命令
在各种shell中运行结果分析：

这个代码只有在 bash 中执行才会出现不断创建进程而耗尽系统资源的严重后果;

在 ksh (Korn shell), sh (Bourne shell)中并不会出现，

在 ksh88 和传统 unix Bourne shell 中冒号不能做函数名，

即便是在 unix-center freebsd 系统中的 sh 和 pdksh（ksh93 手边没有，没试）中冒号可以做函数名，但还是不会出现那个效果。

原因是 sh、ksh 中内置命令的优先级高于函数，所以执行“:”， 总是执行内置命令“:”而不是刚才定义的那个恐怖函数。

但是在 bash 中就不一样，bash 中函数的优先级高于内置命令， 所以执行“:”结果会导致不断的递归，而其中有管道操作， 这就需要创建两个子进程来实现，这样就会不断的创建进程而导致资源耗尽。
众所周知，bash是一款极其强大的shell，提供了强大的交互与编程功能。

这样的一款shell中自然不会缺少“函数”这个元素来帮助程序进行模块化的高效开发与管理。 于是产生了由于其特殊的特性，bash拥有了fork炸弹。

Jaromil在2002年设计了最为精简的一个fork炸弹的实现。

所谓fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环.

fork炸弹并不需要有特别的权限即可对系统造成破坏。

fork炸弹实质是一个简单的递归程序。

由于程序是递归的，如果没有任何限制，

这会导致这个简单的程序迅速耗尽系统里面的所有资源.
